<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>El Impostor - Jugador</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700;900&display=swap" rel="stylesheet">
  <style>
    :root {
      --neon-pink: #FF006E;
      --neon-cyan: #00F5FF;
      --neon-purple: #A855F7;
      --neon-yellow: #FFD60A;
      --neon-green: #00FF88;
      --dark-bg: #0A0A0F;
      --dark-surface: #1A1A24;
      --dark-elevated: #242435;
      --text-primary: #FFFFFF;
      --text-secondary: #A1A1AA;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      background: var(--dark-bg);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
      overflow-x: hidden;
      position: relative;
    }

    /* Animated Background */
    .bg-animation {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      background: linear-gradient(135deg, #0A0A0F 0%, #1A1A24 50%, #0A0A0F 100%);
      background-size: 400% 400%;
      animation: bgMove 15s ease infinite;
    }

    @keyframes bgMove {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    /* Particles */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
    }

    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      background: var(--neon-cyan);
      border-radius: 50%;
      opacity: 0.4;
      animation: float linear infinite;
    }

    @keyframes float {
      0% {
        transform: translateY(100vh) scale(0);
        opacity: 0;
      }
      50% {
        opacity: 0.6;
      }
      100% {
        transform: translateY(-100vh) scale(1);
        opacity: 0;
      }
    }

    .container {
      position: relative;
      z-index: 10;
      background: rgba(26, 26, 36, 0.95);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 30px;
      padding: 45px;
      box-shadow: 0 25px 80px rgba(0, 0, 0, 0.5);
      max-width: 1200px;
      width: 100%;
      text-align: center;
    }

    h1 {
      font-size: 3em;
      font-weight: 900;
      background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 15px;
      letter-spacing: 1px;
    }

    .subtitle {
      color: var(--text-secondary);
      margin-bottom: 35px;
      font-size: 1.2em;
      font-weight: 500;
    }

    .join-section {
      display: block;
    }

    .join-section.hidden {
      display: none;
    }

    .form-group {
      margin-bottom: 28px;
      text-align: left;
    }

    label {
      display: block;
      margin-bottom: 10px;
      color: var(--text-primary);
      font-weight: 600;
      font-size: 1.05em;
    }

    input[type="text"] {
      width: 100%;
      padding: 15px 18px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      font-size: 1.1em;
      background: rgba(36, 36, 53, 0.6);
      color: var(--text-primary);
      font-family: 'Poppins', sans-serif;
      transition: all 0.3s ease;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: var(--neon-cyan);
      background: rgba(36, 36, 53, 0.9);
      box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
    }

    input[type="text"]::placeholder {
      color: var(--text-secondary);
    }

    .btn {
      width: 100%;
      padding: 16px;
      border: none;
      border-radius: 12px;
      font-size: 1.1em;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      background: linear-gradient(135deg, var(--neon-pink), var(--neon-purple));
      color: var(--text-primary);
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 8px 25px rgba(255, 0, 110, 0.4);
    }

    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 35px rgba(255, 0, 110, 0.6);
    }

    .btn:disabled {
      background: rgba(161, 161, 170, 0.3);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .waiting-section {
      display: none;
    }

    .waiting-section.active {
      display: block;
    }

    .player-count {
      font-size: 1.6em;
      font-weight: 700;
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 25px 0;
      text-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
    }

    .players-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 18px;
      margin: 30px 0;
    }

    .player-card {
      background: rgba(36, 36, 53, 0.6);
      backdrop-filter: blur(10px);
      padding: 20px 12px;
      border-radius: 15px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }

    .player-card:hover {
      transform: translateY(-5px);
      border-color: var(--neon-cyan);
      box-shadow: 0 10px 30px rgba(0, 245, 255, 0.3);
      background: rgba(36, 36, 53, 0.9);
    }

    .player-card::before {
      content: "üë§";
      display: block;
      font-size: 2.5em;
      margin-bottom: 12px;
      filter: grayscale(0.2);
    }

    .player-name {
      font-size: 0.95em;
      color: var(--text-primary);
      font-weight: 600;
      word-break: break-word;
    }

    .role-section {
      display: none;
    }

    .role-section.active {
      display: block;
    }

    .role-card {
      margin: 35px 0;
      padding: 50px 40px;
      border-radius: 25px;
      font-size: 3.5em;
      font-weight: 900;
      text-transform: uppercase;
      letter-spacing: 4px;
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.4);
      animation: reveal 1s ease-out;
      border: 2px solid;
    }

    @keyframes reveal {
      0% {
        opacity: 0;
        transform: scale(0.7) rotateY(90deg);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotateY(0deg);
      }
    }

    .impostor {
      background: linear-gradient(135deg, rgba(255, 0, 110, 0.2), rgba(255, 0, 110, 0.05));
      color: var(--neon-pink);
      text-shadow: 0 0 30px rgba(255, 0, 110, 0.8);
      border-color: var(--neon-pink);
      box-shadow: 0 15px 50px rgba(255, 0, 110, 0.5), inset 0 0 50px rgba(255, 0, 110, 0.1);
    }

    .inocente {
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.05));
      color: var(--neon-green);
      text-shadow: 0 0 30px rgba(0, 255, 136, 0.8);
      border-color: var(--neon-green);
      box-shadow: 0 15px 50px rgba(0, 255, 136, 0.5), inset 0 0 50px rgba(0, 255, 136, 0.1);
    }

    .role-description {
      font-size: 1.2em;
      color: var(--text-secondary);
      margin: 25px 0;
      line-height: 1.8;
      font-weight: 500;
    }

    .alert {
      padding: 16px 20px;
      border-radius: 12px;
      margin: 18px 0;
      font-weight: 600;
      border: 1px solid;
    }

    .alert-danger {
      background: rgba(255, 0, 110, 0.1);
      color: var(--neon-pink);
      border-color: rgba(255, 0, 110, 0.3);
    }

    .alert-info {
      background: rgba(0, 245, 255, 0.1);
      color: var(--neon-cyan);
      border-color: rgba(0, 245, 255, 0.3);
    }

    .loading {
      display: inline-block;
      width: 60px;
      height: 60px;
      border: 5px solid rgba(255, 255, 255, 0.1);
      border-top: 5px solid var(--neon-cyan);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin: 25px auto;
      box-shadow: 0 0 30px rgba(0, 245, 255, 0.3);
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Estilos del juego */
    .game-section {
      display: none;
    }

    .game-section.active {
      display: block;
    }

    .my-card {
      background: rgba(36, 36, 53, 0.8);\n      backdrop-filter: blur(15px);\n      border: 2px solid rgba(255, 255, 255, 0.15);\n      border-radius: 20px;\n      padding: 25px;\n      margin: 25px 0;\n      cursor: pointer;\n      transition: all 0.3s ease;\n      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);\n    }\n\n    .my-card:hover {\n      transform: translateY(-8px);\n      box-shadow: 0 15px 40px rgba(0, 245, 255, 0.3);\n      border-color: var(--neon-cyan);\n    }\n\n    .my-card.revealed {\n      cursor: default;\n      border-color: var(--neon-purple);\n    }\n\n    .card-front, .card-back {\n      text-align: center;\n    }\n\n    .card-front h3 {\n      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));\n      -webkit-background-clip: text;\n      -webkit-text-fill-color: transparent;\n      background-clip: text;\n      font-size: 1.4em;\n      margin-bottom: 12px;\n      font-weight: 700;\n    }

    .card-back {
      display: none;
    }

    .card-back.active {
      display: block;
    }

    .card-word {
      font-size: 2.8em;
      font-weight: 900;
      padding: 25px;
      border-radius: 18px;
      margin: 18px 0;
      border: 2px solid;
    }

    .card-word.impostor {
      background: linear-gradient(135deg, rgba(255, 0, 110, 0.2), rgba(255, 0, 110, 0.05));
      color: var(--neon-pink);
      border-color: var(--neon-pink);
      box-shadow: 0 10px 30px rgba(255, 0, 110, 0.4), inset 0 0 30px rgba(255, 0, 110, 0.1);
      text-shadow: 0 0 20px rgba(255, 0, 110, 0.6);
    }

    .card-word.inocente {
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.2), rgba(0, 255, 136, 0.05));
      color: var(--neon-green);
      border-color: var(--neon-green);
      box-shadow: 0 10px 30px rgba(0, 255, 136, 0.4), inset 0 0 30px rgba(0, 255, 136, 0.1);
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
    }

    .turn-info {
      background: rgba(36, 36, 53, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 18px;
      border-radius: 15px;
      margin: 25px 0;
      text-align: center;
      color: var(--text-secondary);
      font-weight: 600;
    }

    .turn-info.my-turn {
      background: linear-gradient(135deg, rgba(255, 214, 10, 0.2), rgba(168, 85, 247, 0.2));
      border-color: var(--neon-yellow);
      color: var(--text-primary);
      animation: pulse 2s infinite;
      box-shadow: 0 8px 25px rgba(255, 214, 10, 0.3);
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.03); }
    }

    .timer {
      font-size: 2.2em;
      font-weight: 900;
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin: 12px 0;
    }

    .timer.warning {
      background: linear-gradient(135deg, var(--neon-pink), #FF4444);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .word-input-section {
      display: none;
      margin: 25px 0;
      padding: 30px;
      background: linear-gradient(135deg, rgba(255, 214, 10, 0.15), rgba(168, 85, 247, 0.15));
      border: 2px solid rgba(255, 214, 10, 0.3);
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(255, 214, 10, 0.2);
    }

    .word-input-section.active {
      display: block;
      animation: slideIn 0.4s ease-out;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-15px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .word-input {
      width: 100%;
      padding: 18px;
      font-size: 1.4em;
      border: 3px solid var(--neon-cyan);
      border-radius: 12px;
      text-align: center;
      text-transform: uppercase;
      font-weight: 700;
      letter-spacing: 3px;
      background: rgba(36, 36, 53, 0.8);
      color: var(--text-primary);
      font-family: 'Poppins', sans-serif;
    }

    .word-input:focus {
      outline: none;
      box-shadow: 0 0 25px rgba(0, 245, 255, 0.4);
      border-color: var(--neon-pink);
    }

    .submit-word-btn {
      width: 100%;
      padding: 16px;
      background: linear-gradient(135deg, var(--neon-pink), var(--neon-purple));
      color: var(--text-primary);
      border: none;
      border-radius: 12px;
      font-size: 1.2em;
      font-weight: 700;
      cursor: pointer;
      margin-top: 15px;
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 8px 25px rgba(255, 0, 110, 0.4);
    }

    .submit-word-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 35px rgba(255, 0, 110, 0.6);
    }

    .chat-section {
      background: rgba(36, 36, 53, 0.6);
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      margin: 25px 0;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .chat-messages {
      height: 400px;
      max-height: 400px;
      overflow-y: auto;
      padding: 18px;
      background: rgba(26, 26, 36, 0.4);
    }

    .chat-message {
      margin: 10px 0;
      padding: 12px 16px;
      background: rgba(36, 36, 53, 0.8);
      border-radius: 12px;
      border-left: 3px solid var(--neon-cyan);
      color: var(--text-secondary);
    }

    .chat-message strong {
      color: var(--neon-cyan);
      font-weight: 700;
    }

    .chat-input-container {
      display: flex;
      padding: 18px;
      background: rgba(36, 36, 53, 0.8);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .chat-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      font-size: 1em;
      background: rgba(26, 26, 36, 0.6);
      color: var(--text-primary);
      font-family: 'Poppins', sans-serif;
    }

    .chat-input:focus {
      outline: none;
      border-color: var(--neon-cyan);
      box-shadow: 0 0 15px rgba(0, 245, 255, 0.2);
    }

    .chat-input:disabled {
      background: rgba(161, 161, 170, 0.1);
      cursor: not-allowed;
      opacity: 0.5;
    }

    .send-btn {
      margin-left: 12px;
      padding: 12px 24px;
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
      color: var(--text-primary);
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      font-family: 'Poppins', sans-serif;
      transition: all 0.3s ease;
    }

    .send-btn:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 245, 255, 0.4);
    }

    .send-btn:disabled {
      background: rgba(161, 161, 170, 0.3);
      cursor: not-allowed;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* Estilos para la interfaz de llamada de voz */
    .voice-call-container {
      background: rgba(36, 36, 53, 0.6);
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      height: 100%;
    }

    .voice-call-header {
      color: var(--text-primary);
      padding: 18px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(26, 26, 36, 0.4);
      font-weight: 700;
    }

    .voice-toggle-btn {
      background: linear-gradient(135deg, var(--neon-green), #00D9FF);
      color: #0A0A0F;
      border: none;
      padding: 12px 24px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.95em;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      font-family: 'Poppins', sans-serif;
      box-shadow: 0 6px 20px rgba(0, 255, 136, 0.3);
    }

    .voice-toggle-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 30px rgba(0, 255, 136, 0.5);
    }

    .voice-toggle-btn.in-call {
      background: linear-gradient(135deg, var(--neon-pink), #FF4444);
      box-shadow: 0 6px 20px rgba(255, 0, 110, 0.3);
    }

    .voice-toggle-btn.in-call:hover {
      box-shadow: 0 10px 30px rgba(255, 0, 110, 0.5);
    }

    .voice-participants {
      flex: 1;
      overflow-y: auto;
      padding: 18px;
      background: rgba(26, 26, 36, 0.3);
    }

    .voice-participant {
      background: rgba(36, 36, 53, 0.8);
      backdrop-filter: blur(10px);
      border-radius: 15px;
      padding: 16px;
      margin-bottom: 14px;
      display: flex;
      align-items: center;
      gap: 14px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      transition: all 0.3s ease;
      border: 2px solid rgba(255, 255, 255, 0.1);
    }

    .voice-participant.speaking {
      border-color: var(--neon-green);
      box-shadow: 0 8px 25px rgba(0, 255, 136, 0.4);
      transform: scale(1.03);
      background: rgba(36, 36, 53, 1);
    }

    .voice-participant.muted {
      opacity: 0.6;
    }

    .participant-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      color: white;
      flex-shrink: 0;
    }

    .participant-info {
      flex: 1;
    }

    .participant-name {
      font-weight: 600;
      color: #333;
      font-size: 1.1em;
      margin-bottom: 4px;
    }

    .participant-status {
      font-size: 0.85em;
      color: #666;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .voice-controls {
      padding: 15px;
      border-top: 2px solid #e9ecef;
      display: flex;
      justify-content: center;
      gap: 15px;
      background: white;
    }

    .voice-control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 1.3em;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .voice-control-btn.mute-btn {
      background: #667eea;
      color: white;
    }

    .voice-control-btn.mute-btn.muted {
      background: #dc3545;
    }

    .voice-control-btn:hover {
      transform: scale(1.1);
    }

    .voice-control-btn:active {
      transform: scale(0.95);
    }

    .speaking-indicator {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--neon-green);
      animation: pulse-dot 1.5s infinite;
      box-shadow: 0 0 10px var(--neon-green);
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.4; transform: scale(1.3); }
    }

    .muted-indicator {
      color: var(--neon-pink);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .container {
        padding: 30px 25px;
        max-width: 100%;
      }

      h1 {
        font-size: 2.2em;
      }

      .subtitle {
        font-size: 1em;
      }

      .players-grid {
        grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
        gap: 12px;
      }

      .chat-messages {
        height: 300px;
      }
    }

    @media (max-width: 600px) {
      .container {
        padding: 25px 20px;
      }

      h1 {
        font-size: 1.8em;
      }
      
      /* Layout responsive en m√≥viles */
      #gameSection > div[style*="grid"] {
        grid-template-columns: 1fr !important;
      }

      .role-card {
        font-size: 2.2em;
        padding: 35px 25px;
      }

      .card-word {
        font-size: 2.2em;
        padding: 20px;
      }

      .chat-input-container {
        flex-direction: column;
        gap: 10px;
      }

      .send-btn {
        margin-left: 0;
        width: 100%;
      }
    }

    /* Custom Scrollbar */
    ::-webkit-scrollbar {
      width: 10px;
    }

    ::-webkit-scrollbar-track {
      background: var(--dark-bg);
    }

    ::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, var(--neon-pink), var(--neon-cyan));
      border-radius: 10px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-purple));
    }
  </style>
</head>
<body>
  <!-- Animated Background -->
  <div class="bg-animation"></div>
  
  <!-- Floating Particles -->
  <div class="particles" id="particles"></div>

  <div class="container">
    <h1>üé≠ El Impostor</h1>
    <p class="subtitle">¬øQui√©n es el impostor?</p>

    <!-- Perfil del jugador -->
    <div id="playerProfile" style="display: none; background: linear-gradient(135deg, rgba(255, 0, 110, 0.15), rgba(0, 245, 255, 0.15)); border: 1px solid rgba(255, 255, 255, 0.2); color: var(--text-primary); padding: 14px 24px; border-radius: 15px; margin-bottom: 25px; text-align: center; font-weight: 700; font-size: 1.1em; box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);">
      üë§ <span id="profileName"></span>
    </div>

    <!-- Secci√≥n de unirse -->
    <div id="joinSection" class="join-section">
      <div class="form-group">
        <label for="playerName">Tu nombre:</label>
        <input type="text" id="playerName" placeholder="Ingresa tu nombre" maxlength="20">
      </div>
      
      <div class="form-group">
        <label>Elige tu avatar:</label>
        <div id="avatarSelector"></div>
      </div>
      
      <div id="codeSection" class="form-group" style="display: none;">
        <label for="gameCode">C√≥digo de la partida:</label>
        <input type="text" id="gameCode" placeholder="Ingresa el c√≥digo" maxlength="4" style="text-align: center; font-size: 1.5em; font-weight: 700; letter-spacing: 2px;">
      </div>
      
      <button class="btn" onclick="joinGame()">Unirse a la Partida</button>
    </div>

    <!-- Secci√≥n de espera -->
    <div id="waitingSection" class="waiting-section">
      <div class="alert alert-info">
        ‚è≥ Esperando a que todos los jugadores se conecten...
      </div>
      
      <div class="player-count" id="playerCount">0 / 0 jugadores</div>
      
      <div class="players-grid" id="playersGrid"></div>

      <p style="color: #666; margin-top: 20px;">
        El admin iniciar√° la partida cuando todos est√©n listos
      </p>
    </div>

    <!-- Secci√≥n de juego -->
    <div id="gameSection" class="game-section">
      <!-- Pantalla de revelaci√≥n inicial -->
      <div id="revealScreen" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999;">
        <div style="background: white; padding: 50px; border-radius: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); text-align: center; max-width: 600px;">
          <h2 style="color: #333; font-size: 2em; margin-bottom: 30px;">Tu palabra es:</h2>
          <div id="revealWord" style="font-size: 4em; font-weight: 800; padding: 40px; border-radius: 20px; margin: 20px 0; animation: pulse 2s infinite;"></div>
          <p style="color: #666; font-size: 1.2em;">Memor√≠zala...</p>
          <div style="margin-top: 30px; font-size: 1.5em; color: #667eea; font-weight: 700;" id="revealTimer">10</div>
        </div>
      </div>
      
      <!-- Layout de dos columnas -->\n      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <!-- Panel izquierdo: Info del juego -->
        <div>
          <!-- Mi carta con palabra/rol -->
          <div id="myCard" class="my-card" onclick="toggleCard()">
            <div class="card-front" id="cardFront">
              <h3>üé¥ Tu Carta</h3>
              <p style="color: #666;">Haz clic para revelar/ocultar</p>
            </div>
            <div class="card-back" id="cardBack">
              <div class="card-word" id="cardWord"></div>
            </div>
          </div>

          <!-- Informaci√≥n del turno -->
          <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <h3 style="color: #333; margin-bottom: 15px; text-align: center;">üìä Estado del Juego</h3>
            <div style="text-align: center; margin-bottom: 15px;">
              <p style="font-size: 1.1em; color: #666; margin-bottom: 5px;"><strong>Turno de:</strong></p>
              <p style="font-size: 1.3em; color: #667eea; font-weight: 700;" id="currentPlayerName">-</p>
            </div>
            <div style="text-align: center; margin-bottom: 15px;">
              <div class="timer" id="timer" style="font-size: 3em; margin: 10px 0;">--</div>
            </div>
            <div style="text-align: center;">
              <p style="font-size: 1.1em; color: #666;" id="phaseText">-</p>
            </div>
          </div>

          <!-- Secci√≥n para escribir palabra (solo cuando es tu turno) -->
          <div class="word-input-section" id="wordInputSection">
            <input type="text" 
                   class="word-input" 
                   id="wordInput" 
                   placeholder="Escribe una palabra relacionada" 
                   maxlength="20">
            <button class="submit-word-btn" onclick="submitWord()">
              ‚úçÔ∏è Enviar Palabra
            </button>
          </div>
        </div>
        
        <!-- Panel derecho: Chat / Llamada de Voz -->
        <div style="display: flex; flex-direction: column; gap: 15px;">
          <!-- Panel de Voz (oculto por defecto, se muestra arriba cuando est√° activo) -->
          <div id="voiceCallPanel" style="display: none; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <div class="voice-call-header">
              <h3 style="margin: 0;">üé§ Llamada de Voz</h3>
              <button class="voice-toggle-btn in-call" onclick="toggleVoiceCall()" id="voiceExitBtn">
                üìû Salir de la Llamada
              </button>
            </div>
            <div class="voice-participants" id="voiceParticipants" style="max-height: 250px; overflow-y: auto;">
              <div style="text-align: center; color: #666; padding: 20px;">
                Conect√°ndote a la llamada...
              </div>
            </div>
            <div class="voice-controls">
              <button class="voice-control-btn mute-btn" onclick="toggleMute()" id="muteBtn" title="Silenciar/Activar micr√≥fono">
                üé§
              </button>
            </div>
          </div>

          <!-- Panel de Chat (siempre visible) -->
          <div id="chatPanel" style="background: white; border-radius: 10px; display: flex; flex-direction: column; box-shadow: 0 2px 10px rgba(0,0,0,0.1); flex: 1;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 2px solid #e9ecef;">
              <h3 style="color: #333; margin: 0;">üí¨ Chat</h3>
              <button class="voice-toggle-btn" onclick="toggleVoiceCall()" id="voiceToggleBtn">
                üé§ Entrar en Llamada
              </button>
            </div>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
              <input type="text" 
                     class="chat-input" 
                     id="chatInput" 
                     placeholder="Escribe un mensaje..." 
                     onkeypress="if(event.key==='Enter') sendMessage()">
              <button class="send-btn" onclick="sendMessage()">Enviar</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div id="alertContainer"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="/avatars.js"></script>
  <script>
    const socket = io();
    let gameId = null;
    let playerName = null;
    let playerAvatar = null;

    // Obtener gameId de la URL
    const pathParts = window.location.pathname.split('/');
    gameId = pathParts[pathParts.length - 1];
    
    // Verificar si viene del admin (auto-unirse inmediatamente)
    async function checkAdminAutoJoin() {
      const autoJoinName = sessionStorage.getItem('autoJoinName');
      const autoJoinGameId = sessionStorage.getItem('autoJoinGameId');
      
      if (autoJoinName && autoJoinGameId === gameId) {
        console.log('üëë Admin auto-join detectado');
        playerName = autoJoinName;
        
        // Limpiar sessionStorage
        sessionStorage.removeItem('autoJoinName');
        sessionStorage.removeItem('autoJoinGameId');
        
        // Ocultar formulario
        document.getElementById('joinSection').classList.add('hidden');
        
        // Mostrar perfil
        document.getElementById('playerProfile').style.display = 'block';
        document.getElementById('profileName').textContent = playerName;
        
        // Verificar estado del juego
        try {
          const response = await fetch(`/api/game/${gameId}`);
          const data = await response.json();
          
          if (data.started) {
            // El juego ya empez√≥, el socket ya debe tener la info
            console.log('El juego ya est√° iniciado, esperando evento game-started...');
            // La pantalla de juego se mostrar√° cuando llegue el evento 'game-started'
          } else {
            // Mostrar sala de espera
            document.getElementById('waitingSection').classList.add('active');
          }
        } catch (error) {
          console.error('Error verificando estado del juego:', error);
          document.getElementById('waitingSection').classList.add('active');
        }
        
        return true;
      }
      return false;
    }
    
    // Verificar si la partida es privada
    async function checkGamePrivacy() {
      try {
        const response = await fetch(`/api/game/${gameId}`);
        const data = await response.json();
        
        if (data.isPrivate) {
          document.getElementById('codeSection').style.display = 'block';
        }
      } catch (error) {
        console.error('Error verificando privacidad de la partida:', error);
      }
    }
    
    // Inicializar selector de avatar
    function initAvatarSelector() {
      const container = document.getElementById('avatarSelector');
      if (container) {
        const selector = createAvatarSelector();
        container.appendChild(selector);
      }
    }
    
    // Ejecutar al cargar
    (async () => {
      initAvatarSelector();
      const isAdmin = await checkAdminAutoJoin();
      if (!isAdmin) {
        await checkGamePrivacy();
      }
    })();

    function showAlert(message, type = 'danger') {
      const alertContainer = document.getElementById('alertContainer');
      alertContainer.innerHTML = `
        <div class="alert alert-${type}">
          ${message}
        </div>
      `;
      setTimeout(() => {
        alertContainer.innerHTML = '';
      }, 5000);
    }

    function joinGame() {
      playerName = document.getElementById('playerName').value.trim();

      if (!playerName) {
        showAlert('Por favor ingresa tu nombre', 'danger');
        return;
      }

      if (playerName.length < 2) {
        showAlert('El nombre debe tener al menos 2 caracteres', 'danger');
        return;
      }
      
      // Obtener avatar seleccionado
      const selectedAvatar = document.querySelector('.avatar-option.selected')?.dataset.avatar || 'avatar1';
      playerAvatar = selectedAvatar;
      
      // Verificar c√≥digo si es necesario
      const codeInput = document.getElementById('gameCode');
      const gameCode = codeInput.value.trim();
      
      if (codeInput.parentElement.style.display !== 'none' && !gameCode) {
        showAlert('Por favor ingresa el c√≥digo de la partida', 'danger');
        return;
      }

      // Emitir evento para unirse con avatar
      socket.emit('join-game', { gameId, playerName, gameCode: gameCode || null, avatar: selectedAvatar });
    }

    // Eventos del socket
    socket.on('joined-successfully', () => {
      document.getElementById('joinSection').classList.add('hidden');
      document.getElementById('waitingSection').classList.add('active');
      
      // Mostrar perfil
      document.getElementById('playerProfile').style.display = 'block';
      document.getElementById('profileName').textContent = playerName;
    });

    socket.on('player-joined', (data) => {
      updatePlayersGrid(data.players);
      updatePlayerCount(data.currentCount, data.totalCount);
    });

    socket.on('player-left', (data) => {
      updatePlayersGrid(data.players);
      updatePlayerCount(data.currentCount, data.totalCount);
      showAlert(`${data.playerName} ha abandonado la partida`, 'danger');
    });

    socket.on('game-started', (data) => {
      console.log('üéÆ Juego iniciado:', data);
      
      // Ocultar sala de espera y mostrar juego
      document.getElementById('waitingSection').classList.remove('active');
      document.getElementById('gameSection').classList.add('active');
      
      // Guardar datos del juego
      window.gameData = {
        role: data.role,
        word: data.word,
        playerIndex: data.playerIndex,
        allPlayers: data.allPlayers,
        currentTurn: data.currentTurn,
        totalPlayers: data.totalPlayers,
        cardRevealed: false
      };
      
      // Configurar carta
      const cardWord = document.getElementById('cardWord');
      if (data.role === 'impostor') {
        cardWord.textContent = 'üî¥ IMPOSTOR';
        cardWord.className = 'card-word impostor';
      } else {
        cardWord.textContent = data.word;
        cardWord.className = 'card-word inocente';
      }
      
      // Mostrar palabra o IMPOSTOR en la pantalla de revelaci√≥n
      const revealWord = document.getElementById('revealWord');
      if (data.role === 'impostor') {
        revealWord.textContent = 'üé≠ IMPOSTOR';
        revealWord.style.background = 'linear-gradient(135deg, #ff6b6b, #c92a2a)';
        revealWord.style.color = 'white';
      } else {
        revealWord.textContent = data.word;
        revealWord.style.background = 'linear-gradient(135deg, #51cf66, #2f9e44)';
        revealWord.style.color = 'white';
      }
      
      // Iniciar cuenta regresiva de revelaci√≥n (10 segundos)
      let revealSeconds = 10;
      const revealTimerEl = document.getElementById('revealTimer');
      const revealScreen = document.getElementById('revealScreen');
      
      const revealInterval = setInterval(() => {
        revealSeconds--;
        if (revealTimerEl) revealTimerEl.textContent = revealSeconds;
        
        if (revealSeconds <= 0) {
          clearInterval(revealInterval);
          if (revealScreen) revealScreen.style.display = 'none';
        }
      }, 1000);
      
      // Permitir cerrar la pantalla haciendo clic
      if (revealScreen) {
        revealScreen.onclick = () => {
          clearInterval(revealInterval);
          revealScreen.style.display = 'none';
        };
      }
      
      // Iniciar primer turno
      updateTurnInfo(data.currentTurn, data.allPlayers[data.currentTurn].name, 'writing', 45);
    });

    socket.on('game-reset', () => {
      document.getElementById('roleSection').classList.remove('active');
      document.getElementById('waitingSection').classList.add('active');
      showAlert('La partida ha sido reiniciada', 'info');
    });

    socket.on('error', (data) => {
      showAlert(data.message, 'danger');
    });

    function updatePlayersGrid(players) {
      const grid = document.getElementById('playersGrid');
      grid.innerHTML = '';

      players.forEach(player => {
        const card = document.createElement('div');
        card.className = 'player-card';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.alignItems = 'center';
        card.style.gap = '10px';
        
        // Crear avatar
        const avatarContainer = document.createElement('div');
        const avatarElement = createAvatarElement(player.avatar || 'avatar1', 60);
        avatarContainer.appendChild(avatarElement);
        
        const name = document.createElement('div');
        name.className = 'player-name';
        name.textContent = player.name;
        
        card.appendChild(avatarContainer);
        card.appendChild(name);
        grid.appendChild(card);
      });
    }

    function updatePlayerCount(current, total) {
      document.getElementById('playerCount').textContent = 
        `${current} / ${total} jugadores`;
    }

    // ========== FUNCIONES DEL JUEGO ==========
    
    // Tiempo se sincroniza desde el servidor
    window.timeRemaining = 0;

    function toggleCard() {
      const cardFront = document.getElementById('cardFront');
      const cardBack = document.getElementById('cardBack');
      const myCard = document.getElementById('myCard');
      
      if (window.gameData.cardRevealed) {
        // Ocultar
        cardFront.style.display = 'block';
        cardBack.classList.remove('active');
        myCard.classList.remove('revealed');
        window.gameData.cardRevealed = false;
      } else {
        // Revelar
        cardFront.style.display = 'none';
        cardBack.classList.add('active');
        myCard.classList.add('revealed');
        window.gameData.cardRevealed = true;
      }
    }

    function updateTurnInfo(turnIndex, playerName, phase, timeRemaining) {
      console.log(`üîÑ Turno: ${playerName}, Fase: ${phase}, Tiempo: ${timeRemaining}s`);
      console.log(`üéÆ turnIndex: ${turnIndex}, mi playerIndex: ${window.gameData.playerIndex}`);
      
      const currentPlayerName = document.getElementById('currentPlayerName');
      const phaseText = document.getElementById('phaseText');
      const wordInputSection = document.getElementById('wordInputSection');
      const chatInput = document.getElementById('chatInput');
      const sendBtn = document.querySelector('.send-btn');
      
      currentPlayerName.textContent = playerName;
      
      const isMyTurn = turnIndex === window.gameData.playerIndex;
      console.log(`‚ùì ¬øEs mi turno? ${isMyTurn}`);
      
      if (phase === 'writing') {
        // Fase de escritura
        phaseText.textContent = isMyTurn ? '‚úçÔ∏è Es tu turno - Escribe una palabra' : '‚è≥ Esperando...';
        
        // Habilitar input de palabra solo si es mi turno
        if (isMyTurn) {
          wordInputSection.classList.add('active');
          console.log('‚úÖ Input de palabra ACTIVADO');
        } else {
          wordInputSection.classList.remove('active');
          console.log('‚ùå Input de palabra DESACTIVADO');
        }
        
        // MANTENER CHAT HABILITADO TODO EL TIEMPO
        if (chatInput) chatInput.disabled = false;
        if (sendBtn) sendBtn.disabled = false;
        
        // Establecer tiempo inicial del servidor
        window.timeRemaining = timeRemaining;
        updateTimerDisplay();
        
      } else if (phase === 'chatting') {
        // Fase de chat
        phaseText.textContent = 'üí¨ Tiempo de chat';
        wordInputSection.classList.remove('active');
        
        // MANTENER CHAT HABILITADO
        if (chatInput) chatInput.disabled = false;
        if (sendBtn) sendBtn.disabled = false;
        
        // Establecer tiempo inicial del servidor
        window.timeRemaining = timeRemaining;
        updateTimerDisplay();
      }
    }

    function updateTimerDisplay() {
      const timerEl = document.getElementById('timer');
      const minutes = Math.floor(window.timeRemaining / 60);
      const seconds = window.timeRemaining % 60;
      
      timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Agregar clase de advertencia si quedan menos de 10 segundos
      if (window.timeRemaining <= 10 && window.timeRemaining > 0) {
        timerEl.className = 'timer warning';
      } else {
        timerEl.className = 'timer';
      }
    }

    function submitWord() {
      const wordInput = document.getElementById('wordInput');
      const word = wordInput.value.trim().toUpperCase();
      
      if (!word) {
        showAlert('Por favor escribe una palabra', 'danger');
        return;
      }
      
      socket.emit('submit-word', { gameId, word });
      wordInput.value = '';
      document.getElementById('wordInputSection').classList.remove('active');
    }

    function sendMessage() {
      const chatInput = document.getElementById('chatInput');
      const message = chatInput.value.trim();
      
      if (!message) return;
      
      socket.emit('send-message', { gameId, message });
      chatInput.value = '';
    }

    // Permitir enviar con Enter
    document.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const wordInput = document.getElementById('wordInput');
        const chatInput = document.getElementById('chatInput');
        
        if (document.activeElement === wordInput && !wordInput.disabled) {
          submitWord();
        } else if (document.activeElement === chatInput && !chatInput.disabled) {
          sendMessage();
        }
      }
    });

    // Eventos del socket para el juego
    socket.on('next-turn', (data) => {
      console.log('‚û°Ô∏è Siguiente turno:', data);
      window.gameData.currentTurn = data.currentTurn;
      updateTurnInfo(data.currentTurn, data.playerName, data.phase, data.timeRemaining);
    });

    // Recibir actualizaciones de tiempo del servidor
    socket.on('timer-update', (data) => {
      window.timeRemaining = data.timeRemaining;
      updateTimerDisplay();
    });

    socket.on('phase-change', (data) => {
      console.log('üîÑ Cambio de fase:', data);
      updateTurnInfo(
        window.gameData.currentTurn, 
        window.gameData.allPlayers[window.gameData.currentTurn].name,
        data.phase,
        data.duration
      );
    });

    socket.on('word-submitted', (data) => {
      console.log('üìù Palabra enviada:', data);
      addChatMessage(`${data.playerName} escribi√≥: ${data.word}`, true);
    });

    socket.on('timeout-alert', (data) => {
      console.log('‚è∞ Timeout:', data);
      addChatMessage(data.message, false, true); // true para estilo de error
    });

    socket.on('new-message', (data) => {
      addChatMessage(`${data.playerName}: ${data.message}`);
    });

    function addChatMessage(message, isSystem = false, isError = false) {
      const chatMessages = document.getElementById('chatMessages');
      
      // Remover mensaje de bienvenida si existe
      if (chatMessages.children.length === 1 && chatMessages.children[0].style.textAlign === 'center') {
        chatMessages.innerHTML = '';
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = 'chat-message';
      
      if (isError) {
        messageDiv.style.borderLeftColor = '#dc3545';
        messageDiv.style.backgroundColor = '#ffebee';
        messageDiv.innerHTML = `<strong style="color: #dc3545;">‚ö†Ô∏è ${message}</strong>`;
      } else if (isSystem) {
        messageDiv.style.borderLeftColor = '#ffc107';
        messageDiv.innerHTML = `<strong>üéÆ ${message}</strong>`;
      } else {
        const parts = message.split(':');
        if (parts.length > 1) {
          messageDiv.innerHTML = `<strong>${parts[0]}:</strong> ${parts.slice(1).join(':')}`;
        } else {
          messageDiv.textContent = message;
        }
      }
      
      chatMessages.appendChild(messageDiv);
      
      // Scroll autom√°tico hacia abajo con una peque√±a animaci√≥n suave
      setTimeout(() => {
        chatMessages.scrollTo({
          top: chatMessages.scrollHeight,
          behavior: 'smooth'
        });
      }, 10);
    }

    // Prevenir que el usuario cierre accidentalmente
    window.addEventListener('beforeunload', (e) => {
      if (document.getElementById('waitingSection').classList.contains('active') || 
          document.getElementById('gameSection').classList.contains('active')) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    // ============ SISTEMA DE LLAMADAS DE VOZ CON WEBRTC ============
    
    let peer = null;
    let myStream = null;
    let peers = new Map(); // Map de peerId -> {call, audioElement, analyser}
    let isInCall = false;
    let isMuted = false;
    let audioContext = null;
    let myAnalyser = null;

    // Inicializar PeerJS cuando el juego empiece
    function initializePeer() {
      if (peer) return;
      
      const peerId = `${gameId}-${socket.id}`;
      
      peer = new Peer(peerId, {
        host: window.location.hostname,
        port: window.location.port || (window.location.protocol === 'https:' ? 443 : 80),
        path: '/peerjs',
        secure: window.location.protocol === 'https:',
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        }
      });

      peer.on('open', (id) => {
        console.log('üé§ Peer conectado con ID:', id);
        // Notificar al servidor que estoy listo para llamadas
        socket.emit('peer-ready', { gameId, peerId: id, playerName });
      });

      peer.on('call', (call) => {
        console.log('üìû Recibiendo llamada de:', call.peer);
        
        // Si estoy en llamada, contestar autom√°ticamente
        if (isInCall && myStream) {
          call.answer(myStream);
          setupCall(call);
        }
      });

      peer.on('error', (error) => {
        console.error('‚ùå Error de Peer:', error);
      });
    }

    // Configurar una llamada recibida o realizada
    function setupCall(call) {
      call.on('stream', (remoteStream) => {
        console.log('üîä Stream recibido de:', call.peer);
        
        // Crear elemento de audio para reproducir
        const audio = new Audio();
        audio.srcObject = remoteStream;
        audio.play().catch(e => console.error('Error al reproducir audio:', e));
        
        // Configurar an√°lisis de audio para detectar cuando habla
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const source = audioContext.createMediaStreamSource(remoteStream);
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        
        // Guardar referencia
        peers.set(call.peer, {
          call,
          audioElement: audio,
          analyser
        });
        
        // Iniciar detecci√≥n de voz para este peer
        detectVoiceActivity(call.peer, analyser);
      });

      call.on('close', () => {
        console.log('üìû Llamada cerrada:', call.peer);
        const peerData = peers.get(call.peer);
        if (peerData && peerData.audioElement) {
          peerData.audioElement.pause();
          peerData.audioElement.srcObject = null;
        }
        peers.delete(call.peer);
        updateVoiceParticipants();
      });
    }

    // Detectar actividad de voz
    function detectVoiceActivity(peerId, analyser) {
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      function check() {
        if (!peers.has(peerId)) return; // Dejar de chequear si ya no est√°
        
        analyser.getByteFrequencyData(dataArray);
        
        // Calcular volumen promedio
        const average = dataArray.reduce((a, b) => a + b) / bufferLength;
        
        // Umbral de detecci√≥n de voz (ajustable)
        const threshold = 25;
        const isSpeaking = average > threshold;
        
        // Actualizar UI
        updateParticipantSpeaking(peerId, isSpeaking);
        
        requestAnimationFrame(check);
      }
      
      check();
    }

    // Detectar mi propia voz
    function detectMyVoice() {
      if (!myStream || !myAnalyser) return;
      
      const bufferLength = myAnalyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      function check() {
        if (!isInCall) return;
        
        myAnalyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b) / bufferLength;
        const threshold = 25;
        const isSpeaking = average > threshold && !isMuted;
        
        updateParticipantSpeaking(`${gameId}-${socket.id}`, isSpeaking);
        
        requestAnimationFrame(check);
      }
      
      check();
    }

    // Alternar entre chat y llamada de voz
    async function toggleVoiceCall() {
      if (!isInCall) {
        // Entrar en llamada
        await enterVoiceCall();
      } else {
        // Salir de llamada
        leaveVoiceCall();
      }
    }

    // Entrar en la llamada de voz
    async function enterVoiceCall() {
      try {
        console.log('üé§ Entrando en llamada de voz...');
        
        // Solicitar acceso al micr√≥fono
        myStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }, 
          video: false 
        });
        
        // Configurar an√°lisis de mi propia voz
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const source = audioContext.createMediaStreamSource(myStream);
        myAnalyser = audioContext.createAnalyser();
        myAnalyser.fftSize = 256;
        source.connect(myAnalyser);
        
        // Inicializar peer si no existe
        if (!peer) {
          initializePeer();
          // Esperar un momento para que peer se conecte
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        isInCall = true;
        
        // Cambiar UI - Mostrar panel de voz, mantener chat visible
        document.getElementById('voiceCallPanel').style.display = 'block';
        document.getElementById('voiceToggleBtn').style.display = 'none';
        
        // Solicitar lista de peers activos
        socket.emit('request-peers', { gameId });
        
        // Detectar mi voz
        detectMyVoice();
        
        console.log('‚úÖ En llamada de voz');
      } catch (error) {
        console.error('‚ùå Error al acceder al micr√≥fono:', error);
        alert('No se pudo acceder al micr√≥fono. Por favor, otorga los permisos necesarios.');
      }
    }

    // Salir de la llamada de voz
    function leaveVoiceCall() {
      console.log('üìû Saliendo de la llamada...');
      
      // Detener mi stream
      if (myStream) {
        myStream.getTracks().forEach(track => track.stop());
        myStream = null;
      }
      
      // Cerrar todas las llamadas
      peers.forEach((peerData, peerId) => {
        if (peerData.call) {
          peerData.call.close();
        }
        if (peerData.audioElement) {
          peerData.audioElement.pause();
          peerData.audioElement.srcObject = null;
        }
      });
      peers.clear();
      
      isInCall = false;
      isMuted = false;
      
      // Cambiar UI - Ocultar panel de voz, chat ya visible
      document.getElementById('voiceCallPanel').style.display = 'none';
      document.getElementById('voiceToggleBtn').style.display = 'inline-flex';
      
      // Actualizar bot√≥n de mute
      const muteBtn = document.getElementById('muteBtn');
      muteBtn.classList.remove('muted');
      muteBtn.textContent = 'üé§';
      
      console.log('‚úÖ Llamada finalizada');
    }

    // Silenciar/Activar micr√≥fono
    function toggleMute() {
      if (!myStream) return;
      
      isMuted = !isMuted;
      myStream.getAudioTracks()[0].enabled = !isMuted;
      
      const muteBtn = document.getElementById('muteBtn');
      if (isMuted) {
        muteBtn.classList.add('muted');
        muteBtn.textContent = 'üîá';
      } else {
        muteBtn.classList.remove('muted');
        muteBtn.textContent = 'üé§';
      }
      
      // Notificar cambio de estado
      socket.emit('mute-status', { gameId, playerName, isMuted });
      updateVoiceParticipants();
    }

    // Actualizar lista de participantes en la llamada
    function updateVoiceParticipants() {
      const container = document.getElementById('voiceParticipants');
      if (!container) return;
      
      // Obtener lista de jugadores del juego
      const allPlayers = window.gameData?.allPlayers || [];
      
      container.innerHTML = '';
      
      // Agregar mi propio participante primero
      const myParticipant = createParticipantElement(playerName, playerAvatar, true, isMuted, false);
      container.appendChild(myParticipant);
      
      // Agregar otros jugadores
      allPlayers.forEach(player => {
        if (player.name !== playerName) {
          const participant = createParticipantElement(player.name, player.avatar, false, false, false);
          container.appendChild(participant);
        }
      });
    }

    // Crear elemento visual de participante
    function createParticipantElement(name, avatar, isMe, muted, speaking) {
      const div = document.createElement('div');
      div.className = 'voice-participant';
      div.dataset.participantName = name;
      if (speaking) div.classList.add('speaking');
      if (muted) div.classList.add('muted');
      
      const avatarContainer = document.createElement('div');
      avatarContainer.className = 'participant-avatar';
      const avatarElement = createAvatarElement(avatar || 'avatar1', 40);
      avatarContainer.appendChild(avatarElement);
      
      const info = document.createElement('div');
      info.className = 'participant-info';
      
      const nameEl = document.createElement('div');
      nameEl.className = 'participant-name';
      nameEl.textContent = name + (isMe ? ' (T√∫)' : '');
      
      const status = document.createElement('div');
      status.className = 'participant-status';
      
      if (muted) {
        status.innerHTML = '<span class="muted-indicator">üîá</span> Silenciado';
      } else if (speaking) {
        status.innerHTML = '<div class="speaking-indicator"></div> Hablando...';
      } else {
        status.innerHTML = 'üé§ En llamada';
      }
      
      info.appendChild(nameEl);
      info.appendChild(status);
      div.appendChild(avatarContainer);
      div.appendChild(info);
      
      return div;
    }

    // Actualizar indicador visual cuando alguien habla
    function updateParticipantSpeaking(peerId, isSpeaking) {
      // Encontrar el nombre del jugador por peerId
      // El peerId tiene formato: gameId-socketId
      const participants = document.querySelectorAll('.voice-participant');
      
      // Para mi propio peer
      if (peerId === `${gameId}-${socket.id}`) {
        const myParticipant = document.querySelector(`.voice-participant[data-participant-name="${playerName}"]`);
        if (myParticipant) {
          if (isSpeaking) {
            myParticipant.classList.add('speaking');
            const status = myParticipant.querySelector('.participant-status');
            status.innerHTML = '<div class="speaking-indicator"></div> Hablando...';
          } else {
            myParticipant.classList.remove('speaking');
            const status = myParticipant.querySelector('.participant-status');
            if (isMuted) {
              status.innerHTML = '<span class="muted-indicator">üîá</span> Silenciado';
            } else {
              status.innerHTML = 'üé§ En llamada';
            }
          }
        }
      }
      // Para otros peers, necesitamos mapear el peerId al nombre
      // Esto se maneja en el evento 'peers-list'
    }

    // Eventos de Socket.io para coordinaci√≥n de llamadas
    socket.on('peers-list', (data) => {
      console.log('üìã Lista de peers recibida:', data.peers);
      
      // Llamar a cada peer en la lista
      data.peers.forEach(peerInfo => {
        if (peerInfo.peerId !== `${gameId}-${socket.id}` && !peers.has(peerInfo.peerId)) {
          console.log('üìû Llamando a:', peerInfo.playerName, peerInfo.peerId);
          const call = peer.call(peerInfo.peerId, myStream);
          setupCall(call);
        }
      });
      
      updateVoiceParticipants();
    });

    socket.on('new-peer', (data) => {
      console.log('üë§ Nuevo peer disponible:', data.playerName, data.peerId);
      
      // Si estoy en llamada, llamar al nuevo peer
      if (isInCall && myStream && data.peerId !== `${gameId}-${socket.id}`) {
        setTimeout(() => {
          const call = peer.call(data.peerId, myStream);
          setupCall(call);
        }, 500);
      }
    });

    socket.on('peer-left', (data) => {
      console.log('üëã Peer se fue:', data.peerId);
      const peerData = peers.get(data.peerId);
      if (peerData) {
        if (peerData.call) peerData.call.close();
        if (peerData.audioElement) {
          peerData.audioElement.pause();
          peerData.audioElement.srcObject = null;
        }
        peers.delete(data.peerId);
      }
      updateVoiceParticipants();
    });

    socket.on('mute-status-update', (data) => {
      console.log('üîá Estado de mute actualizado:', data.playerName, data.isMuted);
      updateVoiceParticipants();
    });

    // Inicializar peer cuando el juego empiece
    socket.on('game-started', (data) => {
      // ... c√≥digo existente de game-started ...
      
      // Inicializar sistema de voz
      setTimeout(() => {
        initializePeer();
      }, 1000);
    });

    // Generar part√≠culas flotantes
    function createParticles() {
      const particlesContainer = document.getElementById('particles');
      const particleCount = 15;

      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.animationDuration = `${Math.random() * 10 + 15}s`;
        particle.style.animationDelay = `${Math.random() * 5}s`;
        
        // Color aleatorio entre cyan, pink y purple
        const colors = ['#00F5FF', '#FF006E', '#A855F7'];
        particle.style.background = colors[Math.floor(Math.random() * colors.length)];
        
        particlesContainer.appendChild(particle);
      }
    }

    createParticles();

  </script>
</body>
</html>
