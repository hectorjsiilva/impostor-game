<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>El Impostor - Jugador</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .container {
      background: white;
      border-radius: 20px;
      padding: 40px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      max-width: 1200px;
      width: 100%;
      text-align: center;
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
      font-size: 2.5em;
    }

    .subtitle {
      color: #666;
      margin-bottom: 30px;
      font-size: 1.1em;
    }

    .join-section {
      display: block;
    }

    .join-section.hidden {
      display: none;
    }

    .form-group {
      margin-bottom: 25px;
      text-align: left;
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #333;
      font-weight: 600;
      font-size: 1.1em;
    }

    input[type="text"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 1.1em;
      transition: border-color 0.3s;
    }

    input[type="text"]:focus {
      outline: none;
      border-color: #667eea;
    }

    .btn {
      width: 100%;
      padding: 15px;
      border: none;
      border-radius: 10px;
      font-size: 1.2em;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .waiting-section {
      display: none;
    }

    .waiting-section.active {
      display: block;
    }

    .player-count {
      font-size: 1.5em;
      font-weight: 600;
      color: #667eea;
      margin: 20px 0;
    }

    .players-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 15px;
      margin: 25px 0;
    }

    .player-card {
      background: #f8f9fa;
      padding: 15px 10px;
      border-radius: 10px;
      border: 2px solid #e9ecef;
    }

    .player-card::before {
      content: "üë§";
      display: block;
      font-size: 2em;
      margin-bottom: 8px;
    }

    .player-name {
      font-size: 0.9em;
      color: #333;
      font-weight: 600;
      word-break: break-word;
    }

    .role-section {
      display: none;
    }

    .role-section.active {
      display: block;
    }

    .role-card {
      margin: 30px 0;
      padding: 40px;
      border-radius: 20px;
      font-size: 3em;
      font-weight: 800;
      text-transform: uppercase;
      letter-spacing: 3px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      animation: reveal 0.8s ease-out;
    }

    @keyframes reveal {
      0% {
        opacity: 0;
        transform: scale(0.8) rotateY(90deg);
      }
      100% {
        opacity: 1;
        transform: scale(1) rotateY(0deg);
      }
    }

    .impostor {
      background: linear-gradient(135deg, #ff0844 0%, #ffb199 100%);
      color: white;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .inocente {
      background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
      color: white;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .role-description {
      font-size: 1.2em;
      color: #666;
      margin: 20px 0;
      line-height: 1.6;
    }

    .alert {
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
    }

    .alert-danger {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }

    .alert-info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }

    .loading {
      display: inline-block;
      width: 50px;
      height: 50px;
      border: 5px solid #f3f3f3;
      border-top: 5px solid #667eea;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Estilos del juego */
    .game-section {
      display: none;
    }

    .game-section.active {
      display: block;
    }

    .my-card {
      background: white;
      border: 3px solid #667eea;
      border-radius: 15px;
      padding: 20px;
      margin: 20px 0;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    .my-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 15px rgba(102, 126, 234, 0.3);
    }

    .my-card.revealed {
      cursor: default;
    }

    .card-front, .card-back {
      text-align: center;
    }

    .card-front h3 {
      color: #667eea;
      font-size: 1.3em;
      margin-bottom: 10px;
    }

    .card-back {
      display: none;
    }

    .card-back.active {
      display: block;
    }

    .card-word {
      font-size: 2.5em;
      font-weight: 800;
      padding: 20px;
      border-radius: 10px;
      margin: 15px 0;
    }

    .card-word.impostor {
      background: linear-gradient(135deg, #ff0844 0%, #ffb199 100%);
      color: white;
    }

    .card-word.inocente {
      background: linear-gradient(135deg, #56ab2f 0%, #a8e6cf 100%);
      color: white;
    }

    .turn-info {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 10px;
      margin: 20px 0;
      text-align: center;
    }

    .turn-info.my-turn {
      background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
      color: white;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }

    .timer {
      font-size: 2em;
      font-weight: 800;
      color: #667eea;
      margin: 10px 0;
    }

    .timer.warning {
      color: #ff0844;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .word-input-section {
      display: none;
      margin: 20px 0;
      padding: 20px;
      background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
      border-radius: 15px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    }

    .word-input-section.active {
      display: block;
      animation: slideIn 0.3s ease-out;
    }
    
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(-10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .word-input {
      width: 100%;
      padding: 15px;
      font-size: 1.3em;
      border: 3px solid #667eea;
      border-radius: 10px;
      text-align: center;
      text-transform: uppercase;
      font-weight: 700;
      letter-spacing: 2px;
    }

    .submit-word-btn {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 10px;
      font-size: 1.2em;
      font-weight: 600;
      cursor: pointer;
      margin-top: 10px;
    }

    .submit-word-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
    }

    .chat-section {
      background: white;
      border-radius: 10px;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }

    .chat-messages {
      height: 400px;
      max-height: 400px;
      overflow-y: auto;
      padding: 15px;
      background: #f8f9fa;
    }

    .chat-message {
      margin: 8px 0;
      padding: 8px 12px;
      background: white;
      border-radius: 8px;
      border-left: 3px solid #667eea;
    }

    .chat-message strong {
      color: #667eea;
    }

    .chat-input-container {
      display: flex;
      padding: 15px;
      background: white;
      border-top: 2px solid #e9ecef;
    }

    .chat-input {
      flex: 1;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1em;
    }

    .chat-input:disabled {
      background: #f8f9fa;
      cursor: not-allowed;
    }

    .send-btn {
      margin-left: 10px;
      padding: 10px 20px;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    .send-btn:hover:not(:disabled) {
      background: #5568d3;
    }

    .send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }

    /* Estilos para la interfaz de llamada de voz */
    .voice-call-container {
      background: white;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      height: 100%;
    }

    .voice-call-header {
      color: #333;
      padding: 15px;
      border-bottom: 2px solid #e9ecef;
      margin: 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .voice-toggle-btn {
      background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.95em;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .voice-toggle-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(40, 167, 69, 0.3);
    }

    .voice-toggle-btn.in-call {
      background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
    }

    .voice-participants {
      flex: 1;
      overflow-y: auto;
      padding: 15px;
      background: #f8f9fa;
    }

    .voice-participant {
      background: white;
      border-radius: 12px;
      padding: 15px;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.05);
      transition: all 0.3s;
      border: 3px solid transparent;
    }

    .voice-participant.speaking {
      border-color: #28a745;
      box-shadow: 0 4px 16px rgba(40, 167, 69, 0.3);
      transform: scale(1.02);
    }

    .voice-participant.muted {
      opacity: 0.7;
    }

    .participant-avatar {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5em;
      color: white;
      flex-shrink: 0;
    }

    .participant-info {
      flex: 1;
    }

    .participant-name {
      font-weight: 600;
      color: #333;
      font-size: 1.1em;
      margin-bottom: 4px;
    }

    .participant-status {
      font-size: 0.85em;
      color: #666;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .voice-controls {
      padding: 15px;
      border-top: 2px solid #e9ecef;
      display: flex;
      justify-content: center;
      gap: 15px;
      background: white;
    }

    .voice-control-btn {
      width: 50px;
      height: 50px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 1.3em;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .voice-control-btn.mute-btn {
      background: #667eea;
      color: white;
    }

    .voice-control-btn.mute-btn.muted {
      background: #dc3545;
    }

    .voice-control-btn:hover {
      transform: scale(1.1);
    }

    .voice-control-btn:active {
      transform: scale(0.95);
    }

    .speaking-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #28a745;
      animation: pulse-dot 1.5s infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }

    .muted-indicator {
      color: #dc3545;
    }

    @media (max-width: 600px) {
      .container {
        padding: 25px;
        max-width: 100%;
      }

      h1 {
        font-size: 2em;
      }
      
      /* Layout responsive en m√≥viles */
      #gameSection > div[style*="grid"] {
        grid-template-columns: 1fr !important;
      }

      .role-card {
        font-size: 2em;
        padding: 30px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üé≠ El Impostor</h1>
    <p class="subtitle">¬øQui√©n es el impostor?</p>

    <!-- Perfil del jugador -->
    <div id="playerProfile" style="display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 20px; border-radius: 10px; margin-bottom: 20px; text-align: center; font-weight: 600; font-size: 1.1em;">
      üë§ <span id="profileName"></span>
    </div>

    <!-- Secci√≥n de unirse -->
    <div id="joinSection" class="join-section">
      <div class="form-group">
        <label for="playerName">Tu nombre:</label>
        <input type="text" id="playerName" placeholder="Ingresa tu nombre" maxlength="20">
      </div>
      
      <div class="form-group">
        <label>Elige tu avatar:</label>
        <div id="avatarSelector"></div>
      </div>
      
      <div id="codeSection" class="form-group" style="display: none;">
        <label for="gameCode">C√≥digo de la partida:</label>
        <input type="text" id="gameCode" placeholder="Ingresa el c√≥digo" maxlength="4" style="text-align: center; font-size: 1.5em; font-weight: 700; letter-spacing: 2px;">
      </div>
      
      <button class="btn" onclick="joinGame()">Unirse a la Partida</button>
    </div>

    <!-- Secci√≥n de espera -->
    <div id="waitingSection" class="waiting-section">
      <div class="alert alert-info">
        ‚è≥ Esperando a que todos los jugadores se conecten...
      </div>
      
      <div class="player-count" id="playerCount">0 / 0 jugadores</div>
      
      <div class="players-grid" id="playersGrid"></div>

      <p style="color: #666; margin-top: 20px;">
        El admin iniciar√° la partida cuando todos est√©n listos
      </p>
    </div>

    <!-- Secci√≥n de juego -->
    <div id="gameSection" class="game-section">
      <!-- Pantalla de revelaci√≥n inicial -->
      <div id="revealScreen" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999;">
        <div style="background: white; padding: 50px; border-radius: 30px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); text-align: center; max-width: 600px;">
          <h2 style="color: #333; font-size: 2em; margin-bottom: 30px;">Tu palabra es:</h2>
          <div id="revealWord" style="font-size: 4em; font-weight: 800; padding: 40px; border-radius: 20px; margin: 20px 0; animation: pulse 2s infinite;"></div>
          <p style="color: #666; font-size: 1.2em;">Memor√≠zala...</p>
          <div style="margin-top: 30px; font-size: 1.5em; color: #667eea; font-weight: 700;" id="revealTimer">10</div>
        </div>
      </div>
      
      <!-- Layout de dos columnas -->\n      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
        <!-- Panel izquierdo: Info del juego -->
        <div>
          <!-- Mi carta con palabra/rol -->
          <div id="myCard" class="my-card" onclick="toggleCard()">
            <div class="card-front" id="cardFront">
              <h3>üé¥ Tu Carta</h3>
              <p style="color: #666;">Haz clic para revelar/ocultar</p>
            </div>
            <div class="card-back" id="cardBack">
              <div class="card-word" id="cardWord"></div>
            </div>
          </div>

          <!-- Informaci√≥n del turno -->
          <div style="background: #f8f9fa; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <h3 style="color: #333; margin-bottom: 15px; text-align: center;">üìä Estado del Juego</h3>
            <div style="text-align: center; margin-bottom: 15px;">
              <p style="font-size: 1.1em; color: #666; margin-bottom: 5px;"><strong>Turno de:</strong></p>
              <p style="font-size: 1.3em; color: #667eea; font-weight: 700;" id="currentPlayerName">-</p>
            </div>
            <div style="text-align: center; margin-bottom: 15px;">
              <div class="timer" id="timer" style="font-size: 3em; margin: 10px 0;">--</div>
            </div>
            <div style="text-align: center;">
              <p style="font-size: 1.1em; color: #666;" id="phaseText">-</p>
            </div>
          </div>

          <!-- Secci√≥n para escribir palabra (solo cuando es tu turno) -->
          <div class="word-input-section" id="wordInputSection">
            <input type="text" 
                   class="word-input" 
                   id="wordInput" 
                   placeholder="Escribe una palabra relacionada" 
                   maxlength="20">
            <button class="submit-word-btn" onclick="submitWord()">
              ‚úçÔ∏è Enviar Palabra
            </button>
          </div>
        </div>
        
        <!-- Panel derecho: Chat / Llamada de Voz -->
        <div style="display: flex; flex-direction: column; gap: 15px;">
          <!-- Panel de Voz (oculto por defecto, se muestra arriba cuando est√° activo) -->
          <div id="voiceCallPanel" style="display: none; background: white; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <div class="voice-call-header">
              <h3 style="margin: 0;">üé§ Llamada de Voz</h3>
              <button class="voice-toggle-btn in-call" onclick="toggleVoiceCall()" id="voiceExitBtn">
                üìû Salir de la Llamada
              </button>
            </div>
            <div class="voice-participants" id="voiceParticipants" style="max-height: 250px; overflow-y: auto;">
              <div style="text-align: center; color: #666; padding: 20px;">
                Conect√°ndote a la llamada...
              </div>
            </div>
            <div class="voice-controls">
              <button class="voice-control-btn mute-btn" onclick="toggleMute()" id="muteBtn" title="Silenciar/Activar micr√≥fono">
                üé§
              </button>
            </div>
          </div>

          <!-- Panel de Chat (siempre visible) -->
          <div id="chatPanel" style="background: white; border-radius: 10px; display: flex; flex-direction: column; box-shadow: 0 2px 10px rgba(0,0,0,0.1); flex: 1;">
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 15px; border-bottom: 2px solid #e9ecef;">
              <h3 style="color: #333; margin: 0;">üí¨ Chat</h3>
              <button class="voice-toggle-btn" onclick="toggleVoiceCall()" id="voiceToggleBtn">
                üé§ Entrar en Llamada
              </button>
            </div>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
              <input type="text" 
                     class="chat-input" 
                     id="chatInput" 
                     placeholder="Escribe un mensaje..." 
                     onkeypress="if(event.key==='Enter') sendMessage()">
              <button class="send-btn" onclick="sendMessage()">Enviar</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

    <div id="alertContainer"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <script src="/avatars.js"></script>
  <script>
    const socket = io();
    let gameId = null;
    let playerName = null;
    let playerAvatar = null;

    // Obtener gameId de la URL
    const pathParts = window.location.pathname.split('/');
    gameId = pathParts[pathParts.length - 1];
    
    // Verificar si viene del admin (auto-unirse inmediatamente)
    async function checkAdminAutoJoin() {
      const autoJoinName = sessionStorage.getItem('autoJoinName');
      const autoJoinGameId = sessionStorage.getItem('autoJoinGameId');
      
      if (autoJoinName && autoJoinGameId === gameId) {
        console.log('üëë Admin auto-join detectado');
        playerName = autoJoinName;
        
        // Limpiar sessionStorage
        sessionStorage.removeItem('autoJoinName');
        sessionStorage.removeItem('autoJoinGameId');
        
        // Ocultar formulario
        document.getElementById('joinSection').classList.add('hidden');
        
        // Mostrar perfil
        document.getElementById('playerProfile').style.display = 'block';
        document.getElementById('profileName').textContent = playerName;
        
        // Verificar estado del juego
        try {
          const response = await fetch(`/api/game/${gameId}`);
          const data = await response.json();
          
          if (data.started) {
            // El juego ya empez√≥, el socket ya debe tener la info
            console.log('El juego ya est√° iniciado, esperando evento game-started...');
            // La pantalla de juego se mostrar√° cuando llegue el evento 'game-started'
          } else {
            // Mostrar sala de espera
            document.getElementById('waitingSection').classList.add('active');
          }
        } catch (error) {
          console.error('Error verificando estado del juego:', error);
          document.getElementById('waitingSection').classList.add('active');
        }
        
        return true;
      }
      return false;
    }
    
    // Verificar si la partida es privada
    async function checkGamePrivacy() {
      try {
        const response = await fetch(`/api/game/${gameId}`);
        const data = await response.json();
        
        if (data.isPrivate) {
          document.getElementById('codeSection').style.display = 'block';
        }
      } catch (error) {
        console.error('Error verificando privacidad de la partida:', error);
      }
    }
    
    // Inicializar selector de avatar
    function initAvatarSelector() {
      const container = document.getElementById('avatarSelector');
      if (container) {
        const selector = createAvatarSelector();
        container.appendChild(selector);
      }
    }
    
    // Ejecutar al cargar
    (async () => {
      initAvatarSelector();
      const isAdmin = await checkAdminAutoJoin();
      if (!isAdmin) {
        await checkGamePrivacy();
      }
    })();

    function showAlert(message, type = 'danger') {
      const alertContainer = document.getElementById('alertContainer');
      alertContainer.innerHTML = `
        <div class="alert alert-${type}">
          ${message}
        </div>
      `;
      setTimeout(() => {
        alertContainer.innerHTML = '';
      }, 5000);
    }

    function joinGame() {
      playerName = document.getElementById('playerName').value.trim();

      if (!playerName) {
        showAlert('Por favor ingresa tu nombre', 'danger');
        return;
      }

      if (playerName.length < 2) {
        showAlert('El nombre debe tener al menos 2 caracteres', 'danger');
        return;
      }
      
      // Obtener avatar seleccionado
      const selectedAvatar = document.querySelector('.avatar-option.selected')?.dataset.avatar || 'avatar1';
      playerAvatar = selectedAvatar;
      
      // Verificar c√≥digo si es necesario
      const codeInput = document.getElementById('gameCode');
      const gameCode = codeInput.value.trim();
      
      if (codeInput.parentElement.style.display !== 'none' && !gameCode) {
        showAlert('Por favor ingresa el c√≥digo de la partida', 'danger');
        return;
      }

      // Emitir evento para unirse con avatar
      socket.emit('join-game', { gameId, playerName, gameCode: gameCode || null, avatar: selectedAvatar });
    }

    // Eventos del socket
    socket.on('joined-successfully', () => {
      document.getElementById('joinSection').classList.add('hidden');
      document.getElementById('waitingSection').classList.add('active');
      
      // Mostrar perfil
      document.getElementById('playerProfile').style.display = 'block';
      document.getElementById('profileName').textContent = playerName;
    });

    socket.on('player-joined', (data) => {
      updatePlayersGrid(data.players);
      updatePlayerCount(data.currentCount, data.totalCount);
    });

    socket.on('player-left', (data) => {
      updatePlayersGrid(data.players);
      updatePlayerCount(data.currentCount, data.totalCount);
      showAlert(`${data.playerName} ha abandonado la partida`, 'danger');
    });

    socket.on('game-started', (data) => {
      console.log('üéÆ Juego iniciado:', data);
      
      // Ocultar sala de espera y mostrar juego
      document.getElementById('waitingSection').classList.remove('active');
      document.getElementById('gameSection').classList.add('active');
      
      // Guardar datos del juego
      window.gameData = {
        role: data.role,
        word: data.word,
        playerIndex: data.playerIndex,
        allPlayers: data.allPlayers,
        currentTurn: data.currentTurn,
        totalPlayers: data.totalPlayers,
        cardRevealed: false
      };
      
      // Configurar carta
      const cardWord = document.getElementById('cardWord');
      if (data.role === 'impostor') {
        cardWord.textContent = 'üî¥ IMPOSTOR';
        cardWord.className = 'card-word impostor';
      } else {
        cardWord.textContent = data.word;
        cardWord.className = 'card-word inocente';
      }
      
      // Mostrar palabra o IMPOSTOR en la pantalla de revelaci√≥n
      const revealWord = document.getElementById('revealWord');
      if (data.role === 'impostor') {
        revealWord.textContent = 'üé≠ IMPOSTOR';
        revealWord.style.background = 'linear-gradient(135deg, #ff6b6b, #c92a2a)';
        revealWord.style.color = 'white';
      } else {
        revealWord.textContent = data.word;
        revealWord.style.background = 'linear-gradient(135deg, #51cf66, #2f9e44)';
        revealWord.style.color = 'white';
      }
      
      // Iniciar cuenta regresiva de revelaci√≥n (10 segundos)
      let revealSeconds = 10;
      const revealTimerEl = document.getElementById('revealTimer');
      const revealScreen = document.getElementById('revealScreen');
      
      const revealInterval = setInterval(() => {
        revealSeconds--;
        if (revealTimerEl) revealTimerEl.textContent = revealSeconds;
        
        if (revealSeconds <= 0) {
          clearInterval(revealInterval);
          if (revealScreen) revealScreen.style.display = 'none';
        }
      }, 1000);
      
      // Permitir cerrar la pantalla haciendo clic
      if (revealScreen) {
        revealScreen.onclick = () => {
          clearInterval(revealInterval);
          revealScreen.style.display = 'none';
        };
      }
      
      // Iniciar primer turno
      updateTurnInfo(data.currentTurn, data.allPlayers[data.currentTurn].name, 'writing', 45);
    });

    socket.on('game-reset', () => {
      document.getElementById('roleSection').classList.remove('active');
      document.getElementById('waitingSection').classList.add('active');
      showAlert('La partida ha sido reiniciada', 'info');
    });

    socket.on('error', (data) => {
      showAlert(data.message, 'danger');
    });

    function updatePlayersGrid(players) {
      const grid = document.getElementById('playersGrid');
      grid.innerHTML = '';

      players.forEach(player => {
        const card = document.createElement('div');
        card.className = 'player-card';
        card.style.display = 'flex';
        card.style.flexDirection = 'column';
        card.style.alignItems = 'center';
        card.style.gap = '10px';
        
        // Crear avatar
        const avatarContainer = document.createElement('div');
        const avatarElement = createAvatarElement(player.avatar || 'avatar1', 60);
        avatarContainer.appendChild(avatarElement);
        
        const name = document.createElement('div');
        name.className = 'player-name';
        name.textContent = player.name;
        
        card.appendChild(avatarContainer);
        card.appendChild(name);
        grid.appendChild(card);
      });
    }

    function updatePlayerCount(current, total) {
      document.getElementById('playerCount').textContent = 
        `${current} / ${total} jugadores`;
    }

    // ========== FUNCIONES DEL JUEGO ==========
    
    // Tiempo se sincroniza desde el servidor
    window.timeRemaining = 0;

    function toggleCard() {
      const cardFront = document.getElementById('cardFront');
      const cardBack = document.getElementById('cardBack');
      const myCard = document.getElementById('myCard');
      
      if (window.gameData.cardRevealed) {
        // Ocultar
        cardFront.style.display = 'block';
        cardBack.classList.remove('active');
        myCard.classList.remove('revealed');
        window.gameData.cardRevealed = false;
      } else {
        // Revelar
        cardFront.style.display = 'none';
        cardBack.classList.add('active');
        myCard.classList.add('revealed');
        window.gameData.cardRevealed = true;
      }
    }

    function updateTurnInfo(turnIndex, playerName, phase, timeRemaining) {
      console.log(`üîÑ Turno: ${playerName}, Fase: ${phase}, Tiempo: ${timeRemaining}s`);
      console.log(`üéÆ turnIndex: ${turnIndex}, mi playerIndex: ${window.gameData.playerIndex}`);
      
      const currentPlayerName = document.getElementById('currentPlayerName');
      const phaseText = document.getElementById('phaseText');
      const wordInputSection = document.getElementById('wordInputSection');
      const chatInput = document.getElementById('chatInput');
      const sendBtn = document.querySelector('.send-btn');
      
      currentPlayerName.textContent = playerName;
      
      const isMyTurn = turnIndex === window.gameData.playerIndex;
      console.log(`‚ùì ¬øEs mi turno? ${isMyTurn}`);
      
      if (phase === 'writing') {
        // Fase de escritura
        phaseText.textContent = isMyTurn ? '‚úçÔ∏è Es tu turno - Escribe una palabra' : '‚è≥ Esperando...';
        
        // Habilitar input de palabra solo si es mi turno
        if (isMyTurn) {
          wordInputSection.classList.add('active');
          console.log('‚úÖ Input de palabra ACTIVADO');
        } else {
          wordInputSection.classList.remove('active');
          console.log('‚ùå Input de palabra DESACTIVADO');
        }
        
        // MANTENER CHAT HABILITADO TODO EL TIEMPO
        if (chatInput) chatInput.disabled = false;
        if (sendBtn) sendBtn.disabled = false;
        
        // Establecer tiempo inicial del servidor
        window.timeRemaining = timeRemaining;
        updateTimerDisplay();
        
      } else if (phase === 'chatting') {
        // Fase de chat
        phaseText.textContent = 'üí¨ Tiempo de chat';
        wordInputSection.classList.remove('active');
        
        // MANTENER CHAT HABILITADO
        if (chatInput) chatInput.disabled = false;
        if (sendBtn) sendBtn.disabled = false;
        
        // Establecer tiempo inicial del servidor
        window.timeRemaining = timeRemaining;
        updateTimerDisplay();
      }
    }

    function updateTimerDisplay() {
      const timerEl = document.getElementById('timer');
      const minutes = Math.floor(window.timeRemaining / 60);
      const seconds = window.timeRemaining % 60;
      
      timerEl.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Agregar clase de advertencia si quedan menos de 10 segundos
      if (window.timeRemaining <= 10 && window.timeRemaining > 0) {
        timerEl.className = 'timer warning';
      } else {
        timerEl.className = 'timer';
      }
    }

    function submitWord() {
      const wordInput = document.getElementById('wordInput');
      const word = wordInput.value.trim().toUpperCase();
      
      if (!word) {
        showAlert('Por favor escribe una palabra', 'danger');
        return;
      }
      
      socket.emit('submit-word', { gameId, word });
      wordInput.value = '';
      document.getElementById('wordInputSection').classList.remove('active');
    }

    function sendMessage() {
      const chatInput = document.getElementById('chatInput');
      const message = chatInput.value.trim();
      
      if (!message) return;
      
      socket.emit('send-message', { gameId, message });
      chatInput.value = '';
    }

    // Permitir enviar con Enter
    document.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        const wordInput = document.getElementById('wordInput');
        const chatInput = document.getElementById('chatInput');
        
        if (document.activeElement === wordInput && !wordInput.disabled) {
          submitWord();
        } else if (document.activeElement === chatInput && !chatInput.disabled) {
          sendMessage();
        }
      }
    });

    // Eventos del socket para el juego
    socket.on('next-turn', (data) => {
      console.log('‚û°Ô∏è Siguiente turno:', data);
      window.gameData.currentTurn = data.currentTurn;
      updateTurnInfo(data.currentTurn, data.playerName, data.phase, data.timeRemaining);
    });

    // Recibir actualizaciones de tiempo del servidor
    socket.on('timer-update', (data) => {
      window.timeRemaining = data.timeRemaining;
      updateTimerDisplay();
    });

    socket.on('phase-change', (data) => {
      console.log('üîÑ Cambio de fase:', data);
      updateTurnInfo(
        window.gameData.currentTurn, 
        window.gameData.allPlayers[window.gameData.currentTurn].name,
        data.phase,
        data.duration
      );
    });

    socket.on('word-submitted', (data) => {
      console.log('üìù Palabra enviada:', data);
      addChatMessage(`${data.playerName} escribi√≥: ${data.word}`, true);
    });

    socket.on('timeout-alert', (data) => {
      console.log('‚è∞ Timeout:', data);
      addChatMessage(data.message, false, true); // true para estilo de error
    });

    socket.on('new-message', (data) => {
      addChatMessage(`${data.playerName}: ${data.message}`);
    });

    function addChatMessage(message, isSystem = false, isError = false) {
      const chatMessages = document.getElementById('chatMessages');
      
      // Remover mensaje de bienvenida si existe
      if (chatMessages.children.length === 1 && chatMessages.children[0].style.textAlign === 'center') {
        chatMessages.innerHTML = '';
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = 'chat-message';
      
      if (isError) {
        messageDiv.style.borderLeftColor = '#dc3545';
        messageDiv.style.backgroundColor = '#ffebee';
        messageDiv.innerHTML = `<strong style="color: #dc3545;">‚ö†Ô∏è ${message}</strong>`;
      } else if (isSystem) {
        messageDiv.style.borderLeftColor = '#ffc107';
        messageDiv.innerHTML = `<strong>üéÆ ${message}</strong>`;
      } else {
        const parts = message.split(':');
        if (parts.length > 1) {
          messageDiv.innerHTML = `<strong>${parts[0]}:</strong> ${parts.slice(1).join(':')}`;
        } else {
          messageDiv.textContent = message;
        }
      }
      
      chatMessages.appendChild(messageDiv);
      
      // Scroll autom√°tico hacia abajo con una peque√±a animaci√≥n suave
      setTimeout(() => {
        chatMessages.scrollTo({
          top: chatMessages.scrollHeight,
          behavior: 'smooth'
        });
      }, 10);
    }

    // Prevenir que el usuario cierre accidentalmente
    window.addEventListener('beforeunload', (e) => {
      if (document.getElementById('waitingSection').classList.contains('active') || 
          document.getElementById('gameSection').classList.contains('active')) {
        e.preventDefault();
        e.returnValue = '';
      }
    });

    // ============ SISTEMA DE LLAMADAS DE VOZ CON WEBRTC ============
    
    let peer = null;
    let myStream = null;
    let peers = new Map(); // Map de peerId -> {call, audioElement, analyser}
    let isInCall = false;
    let isMuted = false;
    let audioContext = null;
    let myAnalyser = null;

    // Inicializar PeerJS cuando el juego empiece
    function initializePeer() {
      if (peer) return;
      
      const peerId = `${gameId}-${socket.id}`;
      
      peer = new Peer(peerId, {
        host: window.location.hostname,
        port: window.location.port || (window.location.protocol === 'https:' ? 443 : 80),
        path: '/peerjs',
        secure: window.location.protocol === 'https:',
        config: {
          iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
          ]
        }
      });

      peer.on('open', (id) => {
        console.log('üé§ Peer conectado con ID:', id);
        // Notificar al servidor que estoy listo para llamadas
        socket.emit('peer-ready', { gameId, peerId: id, playerName });
      });

      peer.on('call', (call) => {
        console.log('üìû Recibiendo llamada de:', call.peer);
        
        // Si estoy en llamada, contestar autom√°ticamente
        if (isInCall && myStream) {
          call.answer(myStream);
          setupCall(call);
        }
      });

      peer.on('error', (error) => {
        console.error('‚ùå Error de Peer:', error);
      });
    }

    // Configurar una llamada recibida o realizada
    function setupCall(call) {
      call.on('stream', (remoteStream) => {
        console.log('üîä Stream recibido de:', call.peer);
        
        // Crear elemento de audio para reproducir
        const audio = new Audio();
        audio.srcObject = remoteStream;
        audio.play().catch(e => console.error('Error al reproducir audio:', e));
        
        // Configurar an√°lisis de audio para detectar cuando habla
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        
        const source = audioContext.createMediaStreamSource(remoteStream);
        const analyser = audioContext.createAnalyser();
        analyser.fftSize = 256;
        source.connect(analyser);
        
        // Guardar referencia
        peers.set(call.peer, {
          call,
          audioElement: audio,
          analyser
        });
        
        // Iniciar detecci√≥n de voz para este peer
        detectVoiceActivity(call.peer, analyser);
      });

      call.on('close', () => {
        console.log('üìû Llamada cerrada:', call.peer);
        const peerData = peers.get(call.peer);
        if (peerData && peerData.audioElement) {
          peerData.audioElement.pause();
          peerData.audioElement.srcObject = null;
        }
        peers.delete(call.peer);
        updateVoiceParticipants();
      });
    }

    // Detectar actividad de voz
    function detectVoiceActivity(peerId, analyser) {
      const bufferLength = analyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      function check() {
        if (!peers.has(peerId)) return; // Dejar de chequear si ya no est√°
        
        analyser.getByteFrequencyData(dataArray);
        
        // Calcular volumen promedio
        const average = dataArray.reduce((a, b) => a + b) / bufferLength;
        
        // Umbral de detecci√≥n de voz (ajustable)
        const threshold = 25;
        const isSpeaking = average > threshold;
        
        // Actualizar UI
        updateParticipantSpeaking(peerId, isSpeaking);
        
        requestAnimationFrame(check);
      }
      
      check();
    }

    // Detectar mi propia voz
    function detectMyVoice() {
      if (!myStream || !myAnalyser) return;
      
      const bufferLength = myAnalyser.frequencyBinCount;
      const dataArray = new Uint8Array(bufferLength);
      
      function check() {
        if (!isInCall) return;
        
        myAnalyser.getByteFrequencyData(dataArray);
        const average = dataArray.reduce((a, b) => a + b) / bufferLength;
        const threshold = 25;
        const isSpeaking = average > threshold && !isMuted;
        
        updateParticipantSpeaking(`${gameId}-${socket.id}`, isSpeaking);
        
        requestAnimationFrame(check);
      }
      
      check();
    }

    // Alternar entre chat y llamada de voz
    async function toggleVoiceCall() {
      if (!isInCall) {
        // Entrar en llamada
        await enterVoiceCall();
      } else {
        // Salir de llamada
        leaveVoiceCall();
      }
    }

    // Entrar en la llamada de voz
    async function enterVoiceCall() {
      try {
        console.log('üé§ Entrando en llamada de voz...');
        
        // Solicitar acceso al micr√≥fono
        myStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          }, 
          video: false 
        });
        
        // Configurar an√°lisis de mi propia voz
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        const source = audioContext.createMediaStreamSource(myStream);
        myAnalyser = audioContext.createAnalyser();
        myAnalyser.fftSize = 256;
        source.connect(myAnalyser);
        
        // Inicializar peer si no existe
        if (!peer) {
          initializePeer();
          // Esperar un momento para que peer se conecte
          await new Promise(resolve => setTimeout(resolve, 1000));
        }
        
        isInCall = true;
        
        // Cambiar UI - Mostrar panel de voz, mantener chat visible
        document.getElementById('voiceCallPanel').style.display = 'block';
        document.getElementById('voiceToggleBtn').style.display = 'none';
        
        // Solicitar lista de peers activos
        socket.emit('request-peers', { gameId });
        
        // Detectar mi voz
        detectMyVoice();
        
        console.log('‚úÖ En llamada de voz');
      } catch (error) {
        console.error('‚ùå Error al acceder al micr√≥fono:', error);
        alert('No se pudo acceder al micr√≥fono. Por favor, otorga los permisos necesarios.');
      }
    }

    // Salir de la llamada de voz
    function leaveVoiceCall() {
      console.log('üìû Saliendo de la llamada...');
      
      // Detener mi stream
      if (myStream) {
        myStream.getTracks().forEach(track => track.stop());
        myStream = null;
      }
      
      // Cerrar todas las llamadas
      peers.forEach((peerData, peerId) => {
        if (peerData.call) {
          peerData.call.close();
        }
        if (peerData.audioElement) {
          peerData.audioElement.pause();
          peerData.audioElement.srcObject = null;
        }
      });
      peers.clear();
      
      isInCall = false;
      isMuted = false;
      
      // Cambiar UI - Ocultar panel de voz, chat ya visible
      document.getElementById('voiceCallPanel').style.display = 'none';
      document.getElementById('voiceToggleBtn').style.display = 'inline-flex';
      
      // Actualizar bot√≥n de mute
      const muteBtn = document.getElementById('muteBtn');
      muteBtn.classList.remove('muted');
      muteBtn.textContent = 'üé§';
      
      console.log('‚úÖ Llamada finalizada');
    }

    // Silenciar/Activar micr√≥fono
    function toggleMute() {
      if (!myStream) return;
      
      isMuted = !isMuted;
      myStream.getAudioTracks()[0].enabled = !isMuted;
      
      const muteBtn = document.getElementById('muteBtn');
      if (isMuted) {
        muteBtn.classList.add('muted');
        muteBtn.textContent = 'üîá';
      } else {
        muteBtn.classList.remove('muted');
        muteBtn.textContent = 'üé§';
      }
      
      // Notificar cambio de estado
      socket.emit('mute-status', { gameId, playerName, isMuted });
      updateVoiceParticipants();
    }

    // Actualizar lista de participantes en la llamada
    function updateVoiceParticipants() {
      const container = document.getElementById('voiceParticipants');
      if (!container) return;
      
      // Obtener lista de jugadores del juego
      const allPlayers = window.gameData?.allPlayers || [];
      
      container.innerHTML = '';
      
      // Agregar mi propio participante primero
      const myParticipant = createParticipantElement(playerName, playerAvatar, true, isMuted, false);
      container.appendChild(myParticipant);
      
      // Agregar otros jugadores
      allPlayers.forEach(player => {
        if (player.name !== playerName) {
          const participant = createParticipantElement(player.name, player.avatar, false, false, false);
          container.appendChild(participant);
        }
      });
    }

    // Crear elemento visual de participante
    function createParticipantElement(name, avatar, isMe, muted, speaking) {
      const div = document.createElement('div');
      div.className = 'voice-participant';
      div.dataset.participantName = name;
      if (speaking) div.classList.add('speaking');
      if (muted) div.classList.add('muted');
      
      const avatarContainer = document.createElement('div');
      avatarContainer.className = 'participant-avatar';
      const avatarElement = createAvatarElement(avatar || 'avatar1', 40);
      avatarContainer.appendChild(avatarElement);
      
      const info = document.createElement('div');
      info.className = 'participant-info';
      
      const nameEl = document.createElement('div');
      nameEl.className = 'participant-name';
      nameEl.textContent = name + (isMe ? ' (T√∫)' : '');
      
      const status = document.createElement('div');
      status.className = 'participant-status';
      
      if (muted) {
        status.innerHTML = '<span class="muted-indicator">üîá</span> Silenciado';
      } else if (speaking) {
        status.innerHTML = '<div class="speaking-indicator"></div> Hablando...';
      } else {
        status.innerHTML = 'üé§ En llamada';
      }
      
      info.appendChild(nameEl);
      info.appendChild(status);
      div.appendChild(avatarContainer);
      div.appendChild(info);
      
      return div;
    }

    // Actualizar indicador visual cuando alguien habla
    function updateParticipantSpeaking(peerId, isSpeaking) {
      // Encontrar el nombre del jugador por peerId
      // El peerId tiene formato: gameId-socketId
      const participants = document.querySelectorAll('.voice-participant');
      
      // Para mi propio peer
      if (peerId === `${gameId}-${socket.id}`) {
        const myParticipant = document.querySelector(`.voice-participant[data-participant-name="${playerName}"]`);
        if (myParticipant) {
          if (isSpeaking) {
            myParticipant.classList.add('speaking');
            const status = myParticipant.querySelector('.participant-status');
            status.innerHTML = '<div class="speaking-indicator"></div> Hablando...';
          } else {
            myParticipant.classList.remove('speaking');
            const status = myParticipant.querySelector('.participant-status');
            if (isMuted) {
              status.innerHTML = '<span class="muted-indicator">üîá</span> Silenciado';
            } else {
              status.innerHTML = 'üé§ En llamada';
            }
          }
        }
      }
      // Para otros peers, necesitamos mapear el peerId al nombre
      // Esto se maneja en el evento 'peers-list'
    }

    // Eventos de Socket.io para coordinaci√≥n de llamadas
    socket.on('peers-list', (data) => {
      console.log('üìã Lista de peers recibida:', data.peers);
      
      // Llamar a cada peer en la lista
      data.peers.forEach(peerInfo => {
        if (peerInfo.peerId !== `${gameId}-${socket.id}` && !peers.has(peerInfo.peerId)) {
          console.log('üìû Llamando a:', peerInfo.playerName, peerInfo.peerId);
          const call = peer.call(peerInfo.peerId, myStream);
          setupCall(call);
        }
      });
      
      updateVoiceParticipants();
    });

    socket.on('new-peer', (data) => {
      console.log('üë§ Nuevo peer disponible:', data.playerName, data.peerId);
      
      // Si estoy en llamada, llamar al nuevo peer
      if (isInCall && myStream && data.peerId !== `${gameId}-${socket.id}`) {
        setTimeout(() => {
          const call = peer.call(data.peerId, myStream);
          setupCall(call);
        }, 500);
      }
    });

    socket.on('peer-left', (data) => {
      console.log('üëã Peer se fue:', data.peerId);
      const peerData = peers.get(data.peerId);
      if (peerData) {
        if (peerData.call) peerData.call.close();
        if (peerData.audioElement) {
          peerData.audioElement.pause();
          peerData.audioElement.srcObject = null;
        }
        peers.delete(data.peerId);
      }
      updateVoiceParticipants();
    });

    socket.on('mute-status-update', (data) => {
      console.log('üîá Estado de mute actualizado:', data.playerName, data.isMuted);
      updateVoiceParticipants();
    });

    // Inicializar peer cuando el juego empiece
    socket.on('game-started', (data) => {
      // ... c√≥digo existente de game-started ...
      
      // Inicializar sistema de voz
      setTimeout(() => {
        initializePeer();
      }, 1000);
    });

  </script>
</body>
</html>
